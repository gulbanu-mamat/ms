# æ•°æ®åº“ç•Œé¢æ»šåŠ¨è§£å†³æ–¹æ¡ˆæŠ€æœ¯æ–‡æ¡£

## ğŸ“‹ ç›®å½•
1. [é—®é¢˜åˆ†æ](#é—®é¢˜åˆ†æ)
2. [ç‹¬ç«‹çª—å£è®¾è®¡](#ç‹¬ç«‹çª—å£è®¾è®¡)
3. [æ»šåŠ¨æœºåˆ¶å®ç°](#æ»šåŠ¨æœºåˆ¶å®ç°)
4. [ç¿»é¡µæ“ä½œè§£å†³æ–¹æ¡ˆ](#ç¿»é¡µæ“ä½œè§£å†³æ–¹æ¡ˆ)
5. [æ•°æ®å¡«å……ç­–ç•¥](#æ•°æ®å¡«å……ç­–ç•¥)
6. [å®Œæ•´ä»£ç å®ç°](#å®Œæ•´ä»£ç å®ç°)
7. [æµ‹è¯•ä¸è°ƒè¯•](#æµ‹è¯•ä¸è°ƒè¯•)

---

## ğŸ” é—®é¢˜åˆ†æ

### åŸå§‹é—®é¢˜
- **æ»šåŠ¨å¤±è´¥**: Database Viewerç•Œé¢æ— æ³•ä¸Šä¸‹æ»šåŠ¨
- **æ•°æ®æ˜¾ç¤ºé™åˆ¶**: åªèƒ½çœ‹åˆ°å‰å‡ æ¡è®°å½•
- **ç”¨æˆ·ä½“éªŒå·®**: æ— æ³•æµè§ˆå®Œæ•´æ•°æ®é›†
- **ç•Œé¢é›†æˆé—®é¢˜**: éœ€è¦ç‹¬ç«‹çš„æ•°æ®åº“ç®¡ç†çª—å£

### æ ¹æœ¬åŸå› 
1. **ncursesé”®ç›˜å¤„ç†**: `keypad()`æœªæ­£ç¡®å¯ç”¨
2. **åˆ†é¡µé€»è¾‘ç¼ºå¤±**: æ²¡æœ‰å®ç°SQLåˆ†é¡µæŸ¥è¯¢
3. **çª—å£åˆ·æ–°é—®é¢˜**: æ•°æ®æ›´æ–°åç•Œé¢æœªæ­£ç¡®åˆ·æ–°
4. **æµ‹è¯•æ•°æ®ä¸è¶³**: æ•°æ®åº“è®°å½•å°‘äºä¸€é¡µæ˜¾ç¤ºé‡

---

## ğŸ–¼ï¸ ç‹¬ç«‹çª—å£è®¾è®¡

### çª—å£æ¶æ„è®¾è®¡
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Database Management Window                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  [1] View Data    [2] Add Data    [3] Statistics    [0] Exit       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Data Display Area â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ ID   Name                Location         Capacity  Created â”‚    â”‚
â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚    â”‚
â”‚  â”‚ 1    Main Warehouse      Beijing          1000      2024-01 â”‚    â”‚
â”‚  â”‚ 2    Branch Warehouse    Shanghai         800       2024-02 â”‚    â”‚
â”‚  â”‚ ...  (æœ€å¤šæ˜¾ç¤º10è¡Œ)                                          â”‚    â”‚
â”‚  â”‚                                                             â”‚    â”‚
â”‚  â”‚ Records 1-10 of 25                                          â”‚    â”‚
â”‚  â”‚ â†‘â†“: Scroll  PgUp/PgDn: Fast  ESC: Return                   â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### çª—å£åˆ›å»ºæ ¸å¿ƒä»£ç 
```c
// åˆ›å»ºç‹¬ç«‹çš„æ•°æ®åº“ç®¡ç†çª—å£
WINDOW* createDatabaseWindow() {
    int height = 22;
    int width = 80;
    int start_y = (LINES - height) / 2;
    int start_x = (COLS - width) / 2;
    
    WINDOW* win = newwin(height, width, start_y, start_x);
    keypad(win, TRUE);  // ğŸ”‘ å…³é”®ï¼šå¯ç”¨æ–¹å‘é”®
    box(win, 0, 0);
    
    return win;
}
```

---

## âš™ï¸ æ»šåŠ¨æœºåˆ¶å®ç°

### æ ¸å¿ƒæ»šåŠ¨ç®—æ³•
```c
typedef struct {
    int offset;          // å½“å‰é¡µèµ·å§‹ä½ç½®
    int max_display;     // æ¯é¡µæ˜¾ç¤ºè®°å½•æ•°
    int total_records;   // æ€»è®°å½•æ•°
    int current_table;   // å½“å‰æŸ¥çœ‹çš„è¡¨
} ScrollState;

// æ»šåŠ¨çŠ¶æ€ç®¡ç†
void handleScrollInput(ScrollState* state, int key) {
    switch (key) {
        case KEY_UP:
            if (state->offset > 0) {
                state->offset--;
            }
            break;
            
        case KEY_DOWN:
            if (state->offset + state->max_display < state->total_records) {
                state->offset++;
            }
            break;
            
        case KEY_PPAGE:  // Page Up
            state->offset -= state->max_display;
            if (state->offset < 0) state->offset = 0;
            break;
            
        case KEY_NPAGE:  // Page Down
            state->offset += state->max_display;
            if (state->offset >= state->total_records) {
                state->offset = state->total_records - state->max_display;
                if (state->offset < 0) state->offset = 0;
            }
            break;
    }
}
```

### SQLåˆ†é¡µæŸ¥è¯¢å®ç°
```c
// åˆ†é¡µæŸ¥è¯¢å‡½æ•°
int queryPagedData(sqlite3* db, const char* table, int offset, int limit, 
                   void (*displayCallback)(sqlite3_stmt*, WINDOW*, int)) {
    char sql[512];
    sprintf(sql, "SELECT * FROM %s ORDER BY id LIMIT %d OFFSET %d", 
            table, limit, offset);
    
    sqlite3_stmt* stmt;
    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, NULL);
    
    if (rc == SQLITE_OK) {
        int row = 0;
        while (sqlite3_step(stmt) == SQLITE_ROW && row < limit) {
            displayCallback(stmt, win, row);
            row++;
        }
    }
    
    sqlite3_finalize(stmt);
    return rc;
}
```

---

## ğŸ“„ ç¿»é¡µæ“ä½œè§£å†³æ–¹æ¡ˆ

### è½¦è¾†æ•°æ®ç¿»é¡µå®ç°
```c
// è½¦è¾†æ•°æ®æ˜¾ç¤ºå›è°ƒå‡½æ•°
void displayVehicleRow(sqlite3_stmt* stmt, WINDOW* win, int row) {
    int start_y = 6;  // æ•°æ®æ˜¾ç¤ºèµ·å§‹è¡Œ
    
    int id = sqlite3_column_int(stmt, 0);
    const char* model = (const char*)sqlite3_column_text(stmt, 1);
    const char* plate = (const char*)sqlite3_column_text(stmt, 2);
    int capacity = sqlite3_column_int(stmt, 3);
    const char* created = (const char*)sqlite3_column_text(stmt, 4);
    
    mvwprintw(win, start_y + row, 2, "%d", id);
    mvwprintw(win, start_y + row, 8, "%.19s", model ? model : "");
    mvwprintw(win, start_y + row, 28, "%.14s", plate ? plate : "");
    mvwprintw(win, start_y + row, 43, "%d", capacity);
    mvwprintw(win, start_y + row, 53, "%.15s", created ? created : "");
}

// è½¦è¾†ç¿»é¡µä¸»å¾ªç¯
void browseVehicles(WINDOW* win) {
    ScrollState state = {0, 10, 0, TABLE_VEHICLES};
    
    // è·å–æ€»è®°å½•æ•°
    state.total_records = getRecordCount(g_database.db, "vehicles");
    
    int key;
    while ((key = wgetch(win)) != 27) {  // ESCé€€å‡º
        // æ¸…é™¤æ•°æ®æ˜¾ç¤ºåŒºåŸŸ
        clearDataArea(win, 6, 16);
        
        // æ˜¾ç¤ºè¡¨å¤´
        displayVehicleHeader(win);
        
        // æŸ¥è¯¢å¹¶æ˜¾ç¤ºå½“å‰é¡µæ•°æ®
        queryPagedData(g_database.db, "vehicles", state.offset, 
                      state.max_display, displayVehicleRow);
        
        // æ˜¾ç¤ºåˆ†é¡µä¿¡æ¯
        displayPageInfo(win, &state);
        
        // å¤„ç†æ»šåŠ¨è¾“å…¥
        handleScrollInput(&state, key);
        
        wrefresh(win);
    }
}
```

### é€šç”¨ç¿»é¡µæ¡†æ¶
```c
// é€šç”¨æ•°æ®æµè§ˆå™¨
typedef struct {
    const char* table_name;
    const char* title;
    void (*display_header)(WINDOW*);
    void (*display_row)(sqlite3_stmt*, WINDOW*, int);
} TableConfig;

void browseTableData(WINDOW* win, TableConfig* config) {
    ScrollState state = {0, 10, 0, 0};
    state.total_records = getRecordCount(g_database.db, config->table_name);
    
    if (state.total_records == 0) {
        displayNoDataMessage(win, config->title);
        return;
    }
    
    int key;
    while ((key = wgetch(win)) != 27) {
        clearDataArea(win, 6, 16);
        config->display_header(win);
        queryPagedData(g_database.db, config->table_name, 
                      state.offset, state.max_display, config->display_row);
        displayPageInfo(win, &state);
        handleScrollInput(&state, key);
        wrefresh(win);
    }
}
```

---

## ğŸ’¾ æ•°æ®å¡«å……ç­–ç•¥

### æ‰¹é‡æ•°æ®ç”Ÿæˆå™¨
```c
// æ•°æ®ç”Ÿæˆå™¨ç»“æ„
typedef struct {
    const char* table_name;
    const char* insert_sql_template;
    int batch_size;
    void (*generate_data)(char* buffer, int index);
} DataGenerator;

// ä»“åº“æ•°æ®ç”Ÿæˆå™¨
void generateWarehouseData(char* buffer, int index) {
    const char* cities[] = {"åŒ—äº¬", "ä¸Šæµ·", "å¹¿å·", "æ·±åœ³", "æˆéƒ½", 
                           "æ­¦æ±‰", "è¥¿å®‰", "å—äº¬", "å“ˆå°”æ»¨", "é’å²›"};
    const char* types[] = {"ä¸»ä»“åº“", "åˆ†ä»“åº“", "é…é€ä¸­å¿ƒ", "å­˜å‚¨ä¸­å¿ƒ", "ç‰©æµä¸­å¿ƒ"};
    
    sprintf(buffer, 
        "INSERT INTO warehouses (name, location, capacity, created_at) VALUES "
        "('%s%d', '%s', %d, datetime('now'));",
        types[index % 5], index + 1,
        cities[index % 10],
        500 + (index * 100) % 1500
    );
}

// æ‰¹é‡æ’å…¥æ•°æ®
int batchInsertData(sqlite3* db, DataGenerator* gen, int count) {
    char sql_buffer[1024];
    int success_count = 0;
    
    for (int i = 0; i < count; i++) {
        gen->generate_data(sql_buffer, i);
        
        if (sqlite3_exec(db, sql_buffer, NULL, NULL, NULL) == SQLITE_OK) {
            success_count++;
        }
    }
    
    return success_count;
}
```

### äº¤äº’å¼æ•°æ®å¡«å……ç•Œé¢
```c
// æ•°æ®å¡«å……èœå•
void showDataFillMenu(WINDOW* win) {
    const char* options[] = {
        "1. æ·»åŠ 10ä¸ªä»“åº“è®°å½•",
        "2. æ·»åŠ 20ä¸ªè´§ç‰©è®°å½•", 
        "3. æ·»åŠ 15ä¸ªè½¦è¾†è®°å½•",
        "4. æ·»åŠ 25ä¸ªè®¢å•è®°å½•",
        "5. æ¸…ç©ºæ‰€æœ‰æ•°æ®",
        "0. è¿”å›"
    };
    
    int choice = showMenuOptions(win, options, 6);
    
    switch (choice) {
        case 0:
            fillWarehouses(10);
            showMessage(win, "æˆåŠŸæ·»åŠ 10ä¸ªä»“åº“è®°å½•");
            break;
        case 1:
            fillGoods(20);
            showMessage(win, "æˆåŠŸæ·»åŠ 20ä¸ªè´§ç‰©è®°å½•");
            break;
        case 2:
            fillVehicles(15);
            showMessage(win, "æˆåŠŸæ·»åŠ 15ä¸ªè½¦è¾†è®°å½•");
            break;
        case 3:
            fillOrders(25);
            showMessage(win, "æˆåŠŸæ·»åŠ 25ä¸ªè®¢å•è®°å½•");
            break;
        case 4:
            if (confirmClearData(win)) {
                clearAllTables();
                showMessage(win, "æ‰€æœ‰æ•°æ®å·²æ¸…ç©º");
            }
            break;
    }
}
```

---

## ğŸ”§ å®Œæ•´ä»£ç å®ç°

### ä¸»è¦æ–‡ä»¶ç»“æ„
```
database_manager.h      // æ•°æ®åº“ç®¡ç†å™¨å¤´æ–‡ä»¶
database_manager.c      // æ•°æ®åº“ç®¡ç†å™¨å®ç°
scroll_handler.h        // æ»šåŠ¨å¤„ç†å™¨å¤´æ–‡ä»¶  
scroll_handler.c        // æ»šåŠ¨å¤„ç†å™¨å®ç°
data_generator.h        // æ•°æ®ç”Ÿæˆå™¨å¤´æ–‡ä»¶
data_generator.c        // æ•°æ®ç”Ÿæˆå™¨å®ç°
```

### æ ¸å¿ƒç®¡ç†å™¨å®ç°
```c
// database_manager.c
#include "database_manager.h"

// æ•°æ®åº“ç®¡ç†å™¨ä¸»çª—å£
void showDatabaseManager() {
    WINDOW* main_win = createDatabaseWindow();
    WINDOW* data_win = derwin(main_win, 12, 76, 8, 2);
    
    keypad(main_win, TRUE);
    keypad(data_win, TRUE);
    
    int current_mode = MODE_BROWSE;
    int current_table = TABLE_WAREHOUSES;
    
    while (1) {
        drawManagerInterface(main_win, current_mode, current_table);
        
        int key = wgetch(main_win);
        
        switch (key) {
            case '1':  // æµè§ˆæ•°æ®
                current_mode = MODE_BROWSE;
                browseCurrentTable(data_win, current_table);
                break;
                
            case '2':  // æ·»åŠ æ•°æ®
                current_mode = MODE_ADD;
                showDataFillMenu(data_win);
                break;
                
            case '3':  // ç»Ÿè®¡ä¿¡æ¯
                current_mode = MODE_STATS;
                showDatabaseStats(data_win);
                break;
                
            case KEY_LEFT:
            case KEY_RIGHT:
                // åˆ‡æ¢è¡¨æ ¼
                current_table = (current_table + 1) % 4;
                break;
                
            case 27:  // ESC
            case '0':
                goto cleanup;
        }
        
        wrefresh(main_win);
    }
    
cleanup:
    delwin(data_win);
    delwin(main_win);
}
```

---

## ğŸ§ª æµ‹è¯•ä¸è°ƒè¯•

### æ»šåŠ¨åŠŸèƒ½æµ‹è¯•ç”¨ä¾‹
```c
// æµ‹è¯•æ»šåŠ¨åŠŸèƒ½
void testScrollFunctionality() {
    printf("=== æ»šåŠ¨åŠŸèƒ½æµ‹è¯• ===\n");
    
    // æµ‹è¯•1: åŸºæœ¬æ»šåŠ¨
    ScrollState state = {0, 10, 25, 0};
    
    // æ¨¡æ‹ŸDOWNé”®
    handleScrollInput(&state, KEY_DOWN);
    assert(state.offset == 1);
    printf("âœ“ å‘ä¸‹æ»šåŠ¨æµ‹è¯•é€šè¿‡\n");
    
    // æ¨¡æ‹ŸUPé”®
    handleScrollInput(&state, KEY_UP);
    assert(state.offset == 0);
    printf("âœ“ å‘ä¸Šæ»šåŠ¨æµ‹è¯•é€šè¿‡\n");
    
    // æµ‹è¯•2: è¾¹ç•Œæ¡ä»¶
    state.offset = 0;
    handleScrollInput(&state, KEY_UP);
    assert(state.offset == 0);  // ä¸åº”è¯¥å°äº0
    printf("âœ“ ä¸Šè¾¹ç•Œæµ‹è¯•é€šè¿‡\n");
    
    state.offset = 20;
    handleScrollInput(&state, KEY_DOWN);
    assert(state.offset == 20);  // ä¸åº”è¯¥è¶…å‡ºèŒƒå›´
    printf("âœ“ ä¸‹è¾¹ç•Œæµ‹è¯•é€šè¿‡\n");
    
    // æµ‹è¯•3: ç¿»é¡µåŠŸèƒ½
    state.offset = 5;
    handleScrollInput(&state, KEY_NPAGE);
    assert(state.offset == 15);
    printf("âœ“ å‘ä¸‹ç¿»é¡µæµ‹è¯•é€šè¿‡\n");
    
    handleScrollInput(&state, KEY_PPAGE);
    assert(state.offset == 5);
    printf("âœ“ å‘ä¸Šç¿»é¡µæµ‹è¯•é€šè¿‡\n");
    
    printf("æ‰€æœ‰æ»šåŠ¨æµ‹è¯•é€šè¿‡ï¼\n");
}
```

### æ€§èƒ½æµ‹è¯•
```c
// å¤§æ•°æ®é›†æ»šåŠ¨æ€§èƒ½æµ‹è¯•
void testLargeDatasetScroll() {
    printf("=== å¤§æ•°æ®é›†æ»šåŠ¨æ€§èƒ½æµ‹è¯• ===\n");
    
    // ç”Ÿæˆ1000æ¡æµ‹è¯•æ•°æ®
    generateTestData(1000);
    
    clock_t start = clock();
    
    // æ¨¡æ‹Ÿå¿«é€Ÿæ»šåŠ¨
    ScrollState state = {0, 10, 1000, 0};
    for (int i = 0; i < 100; i++) {
        handleScrollInput(&state, KEY_NPAGE);
    }
    
    clock_t end = clock();
    double time_spent = ((double)(end - start)) / CLOCKS_PER_SEC;
    
    printf("1000æ¡æ•°æ®ï¼Œ100æ¬¡ç¿»é¡µæ“ä½œè€—æ—¶: %.3fç§’\n", time_spent);
    
    if (time_spent < 1.0) {
        printf("âœ“ æ€§èƒ½æµ‹è¯•é€šè¿‡\n");
    } else {
        printf("âš  æ€§èƒ½éœ€è¦ä¼˜åŒ–\n");
    }
}
```

### è°ƒè¯•æŠ€å·§
```c
// è°ƒè¯•ä¿¡æ¯æ˜¾ç¤º
void debugScrollState(WINDOW* win, ScrollState* state) {
    #ifdef DEBUG
    mvwprintw(win, 1, 2, "DEBUG: offset=%d, total=%d, max_display=%d", 
              state->offset, state->total_records, state->max_display);
    #endif
}

// é”®ç›˜è¾“å…¥è°ƒè¯•
void debugKeyInput(int key) {
    #ifdef DEBUG
    FILE* debug_file = fopen("debug.log", "a");
    fprintf(debug_file, "Key pressed: %d (%s)\n", key, 
            key == KEY_UP ? "UP" : 
            key == KEY_DOWN ? "DOWN" : 
            key == KEY_PPAGE ? "PAGE_UP" : 
            key == KEY_NPAGE ? "PAGE_DOWN" : "OTHER");
    fclose(debug_file);
    #endif
}
```

---

## ğŸ“ æ€»ç»“

### è§£å†³æ–¹æ¡ˆè¦ç‚¹
1. **ç‹¬ç«‹çª—å£**: ä½¿ç”¨`newwin()`åˆ›å»ºç‹¬ç«‹çš„æ•°æ®åº“ç®¡ç†çª—å£
2. **é”®ç›˜å¤„ç†**: æ­£ç¡®å¯ç”¨`keypad(win, TRUE)`
3. **åˆ†é¡µæŸ¥è¯¢**: ä½¿ç”¨SQLçš„`LIMIT`å’Œ`OFFSET`å®ç°åˆ†é¡µ
4. **çŠ¶æ€ç®¡ç†**: ç»´æŠ¤æ»šåŠ¨çŠ¶æ€ç»“æ„ä½“
5. **æ•°æ®å¡«å……**: æä¾›æ‰¹é‡æ•°æ®ç”Ÿæˆå’Œæ’å…¥åŠŸèƒ½

### å…³é”®æŠ€æœ¯ç‚¹
- **ncursesçª—å£ç®¡ç†**: å¤šçª—å£åè°ƒå’Œåˆ·æ–°
- **SQLiteåˆ†é¡µ**: é«˜æ•ˆçš„æ•°æ®åº“åˆ†é¡µæŸ¥è¯¢
- **ç”¨æˆ·äº¤äº’**: å“åº”å¼çš„é”®ç›˜äº‹ä»¶å¤„ç†
- **å†…å­˜ç®¡ç†**: åŠæ—¶é‡Šæ”¾çª—å£å’Œæ•°æ®åº“èµ„æº

### æ‰©å±•å»ºè®®
1. æ·»åŠ æœç´¢å’Œè¿‡æ»¤åŠŸèƒ½
2. å®ç°æ•°æ®æ’åºé€‰é¡¹
3. æ”¯æŒæ•°æ®å¯¼å‡ºåŠŸèƒ½
4. æ·»åŠ æ•°æ®éªŒè¯å’Œé”™è¯¯å¤„ç†
5. å®ç°æ’¤é”€/é‡åšåŠŸèƒ½

è¿™ä¸ªè§£å†³æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„æ•°æ®åº“ç•Œé¢æ»šåŠ¨ã€ç¿»é¡µå’Œæ•°æ®ç®¡ç†åŠŸèƒ½ï¼Œå¯ä»¥å¤„ç†å¤§é‡æ•°æ®å¹¶æä¾›è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒã€‚ 